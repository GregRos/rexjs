{"version":3,"sources":["extension/scalar.ts"],"names":[],"mappings":";AAAA;;GAEG;AACH,IAAO,CAAC,WAAU,QAAQ,CAAC,CAAC;AAC5B,uBAAwB,iBACxB,CAAC,CADwC;AACzC,wBAAqC,yBAAyB,CAAC,CAAA;AAC/D,sBAAuB,gBAAgB,CAAC,CAAA;AA+CxC,IAAM,mBAAmB,GAAI;IAC5B,QAAQ,YAA8B,IAAW,EAAE,IAAW;QAC7D,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC9C,MAAM,CAAC,IAAI,oBAAU,CAAS,IAAI,EAAE,EAAC,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC;QAC7D,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC3B,MAAM,IAAI,SAAS,CAAC,6CAA6C,CAAC,CAAC;QACpE,CAAC;QACD,IAAI,CAAC,CAAC;YACL,MAAM,CAAC,IAAI,oBAAU,CAAS,IAAI,EAAE,IAA0B,CAAC,CAAC;QACjE,CAAC;IACF,CAAC;IAED,QAAQ,YAA6B,EAAuB,EAAE,OAA6C;QAA3G,iBAQC;QAPA,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,UAAA,EAAE;YAClC,IAAI,KAAK,GAAG,CAAC,CAAC,SAAS,CAAC,KAAI,CAAC,KAAK,CAAC,CAAC;YACpC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YACnB,MAAM,CAAC,KAAK,CAAC;QACd,CAAC,CAAC,CAAC;QACH,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG,gBAAQ,CAAC,OAAO,CAAC;QACtC,MAAM,CAAC,QAAQ,CAAC;IACjB,CAAC;IAED,OAAO,YAA6C,UAAmB;QACtE,IAAI,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,UAAU,CAAC,EAAhB,CAAgB,EAAE,UAAC,OAAO,EAAE,KAAK;YACpE,OAAO,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC;QAC7B,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,gBAAQ,CAAC,MAAM,CAAC;QACpC,MAAM,CAAC,OAAO,CAAC;IAChB,CAAC;IAED,MAAM,YAAwB,QAA6B;QAC1D,IAAI,IAAI,GAAG,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACnC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACnB,CAAC;IAED,MAAM,YAAyB,OAA4B;QAC1D,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAClC,CAAC;CACD,CAAC;AAEF,MAAM,CAAC,MAAM,CAAC,kBAAS,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC","file":"extension/scalar.js","sourcesContent":["/**\r\n * Created by Greg on 01/10/2016.\r\n */\r\nimport _ =require('lodash');\r\nimport {RexScalar} from '../rexes/scalar'\r\nimport {Conversion, RexConvert} from \"../rexes/scalar/convert\";\r\nimport {RexNames} from \"../rexes/names\";\r\n\r\ndeclare module '../rexes/scalar' {\r\n\tinterface RexScalar<T> {\r\n\t\t/**\r\n\t\t * Applies a forward and back conversion to this Rex, returning a Convert rex.\r\n\t\t * @param conversion The conversion object.\r\n\t\t */\r\n\t\tconvert_<TTo>(conversion : Conversion<T, TTo>) : RexScalar<TTo>;\r\n\r\n\t\t/**\r\n\t\t * Applies a forward and back conversion to this Rex, returning a Convert rex.\r\n\t\t * @param to The function used to convert outwards. If falsy/omitted, the Rex will not support reading.\r\n\t\t * @param from The function used to convert inwards. If falsy/omitted, the Rex will not support writing.\r\n\t\t */\r\n\t\tconvert_<TTo>(to ?: (from : T) => TTo, from ?: (to : TTo) => T)  : RexScalar<TTo>;\r\n\r\n\t\t/**\r\n\t\t * Applies an assymetric conversion:\r\n\t\t * Forward conversion will use the {to} function.\r\n\t\t * Back conversion will use the {rectifier} function. Here, the {current} parameter is a clone of the current value of this Rex and the {to} parameter is the coerced value. Mutate the {current} parameter to rectify the two values.\r\n\t\t * @param to The forward conversion function.\r\n\t\t * @param rectifier The backward mutation function.\r\n\t\t */\r\n\t\trectify_<TTo>(to ?: (from : T) => TTo, rectifier ?: (current : T, to : TTo) => void) : RexScalar<TTo>;\r\n\r\n\t\t/**\r\n\t\t * Gets the member of the specified name from the Rex.\r\n\t\t * In the back conversion, the current value is cloned and the clone's member is set. Then this rex is updated with the new object.\r\n\t\t * @param name The name of the member to get.\r\n\t\t */\r\n\t\tmember_<TTo>(name : string)  : RexScalar<TTo>;\r\n\r\n\t\t/**\r\n\t\t * Clones the value and applies a mutation on the clone, then updates the Rex with it.\r\n\t\t * @param mutation\r\n\t\t */\r\n\t\tmutate(mutation : (copy : T) => void) : void;\r\n\r\n\t\t/**\r\n\t\t * Takes a function that updates the current value of the Rex to another value.\r\n\t\t * @param reducer\r\n\t\t */\r\n\t\treduce(reducer : (current : T) => T) : void;\r\n\t}\r\n}\r\n\r\nconst RexScalarExtensions =  {\r\n\tconvert_<T, TTo>(this : RexScalar<T>, arg1 ?: any, arg2 ?: any) : RexScalar<TTo> {\r\n\t\tif (_.isFunction(arg1) || _.isFunction(arg2)) {\r\n\t\t\treturn new RexConvert<T, TTo>(this, {to: arg1, from: arg2});\r\n\t\t} else if (!arg1 && !arg2) {\r\n\t\t\tthrow new TypeError(\"failed to match any overload for 'convert'.\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn new RexConvert<T, TTo>(this, arg1 as Conversion<T, TTo>);\r\n\t\t}\r\n\t},\r\n\r\n\trectify_<T, TTo>(this : RexScalar<T>,to ?: (from : T) => TTo, rectify ?: (current : T, input : TTo) => void)  {\r\n\t\tlet rectify_ = this.convert_(to, to => {\r\n\t\t\tlet clone = _.cloneDeep(this.value);\r\n\t\t\trectify(clone, to);\r\n\t\t\treturn clone;\r\n\t\t});\r\n\t\trectify_.info.type = RexNames.Rectify;\r\n\t\treturn rectify_;\r\n\t},\r\n\r\n\tmember_<T extends Object, TTo>(this : RexScalar<T>, memberName : string) {\r\n\t\tlet member_ = this.rectify_(from => from[memberName], (current, input) => {\r\n\t\t\tcurrent[memberName] = input;\r\n\t\t});\r\n\t\tmember_.info.type = RexNames.Member;\r\n\t\treturn member_;\r\n\t},\r\n\r\n\tmutate<T>(this :RexScalar<T>, mutation : (copy : T) => void) : void {\r\n\t\tlet copy = _.cloneDeep(this.value);\r\n\t\tmutation(copy);\r\n\t\tthis.value = copy;\r\n\t},\r\n\r\n\treduce<T>(this : RexScalar<T>, reducer : (current : T) => T) {\r\n\t\tthis.value = reducer(this.value);\r\n\t}\r\n};\r\n\r\nObject.assign(RexScalar.prototype, RexScalarExtensions);"],"sourceRoot":"/src"}