{"version":3,"sources":["extension/scalar.ts"],"names":[],"mappings":";;;;;;AAAA;;GAEG;AACH,IAAO,CAAC,WAAU,QAAQ,CAAC,CAAC;AAC5B,uBAAwB,iBACxB,CAAC,CADwC;AACzC,wBAAqC,yBAAyB,CAAC,CAAA;AAc/D;IAA8C,uCAAY;IAA1D;QAA8C,8BAAY;IAmC1D,CAAC;IAlCA,qCAAO,GAAP,UAAa,IAAW,EAAE,IAAW;QACpC,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC9C,MAAM,CAAC,IAAI,oBAAU,CAAS,IAAI,EAAE,EAAC,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAC,CAAC,CAAC;QAC7D,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC3B,MAAM,IAAI,SAAS,CAAC,6CAA6C,CAAC,CAAC;QACpE,CAAC;QACD,IAAI,CAAC,CAAC;YACL,MAAM,CAAC,IAAI,oBAAU,CAAS,IAAI,EAAE,IAA0B,CAAC,CAAC;QACjE,CAAC;IACF,CAAC;IAED,qCAAO,GAAP,UAAa,EAAuB,EAAE,OAAuC;QAA7E,iBAMC;QALA,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,EAAE,UAAA,EAAE;YACzB,IAAI,KAAK,GAAG,CAAC,CAAC,SAAS,CAAC,KAAI,CAAC,KAAK,CAAC,CAAC;YACpC,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;YACnB,MAAM,CAAC,KAAK,CAAC;QACd,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,oCAAM,GAAN,UAAO,QAA6B;QACnC,IAAI,IAAI,GAAG,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACnC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACnB,CAAC;IAED,oCAAM,GAAN,UAAY,UAAmB;QAC9B,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,UAAU,CAAC,EAAhB,CAAgB,EAAE,UAAC,EAAE,EAAE,IAAI;YACtD,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;QACvB,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,oCAAM,GAAN,UAAO,OAA4B;QAClC,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAClC,CAAC;IACF,0BAAC;AAAD,CAnCA,AAmCC,CAnC6C,kBAAS,GAmCtD;AAED,MAAM,CAAC,MAAM,CAAC,kBAAS,CAAC,SAAS,EAAE,mBAAmB,CAAC,SAAS,CAAC,CAAC","file":"extension/scalar.js","sourcesContent":["/**\r\n * Created by Greg on 01/10/2016.\r\n */\r\nimport _ =require('lodash');\r\nimport {RexScalar} from '../rexes/scalar'\r\nimport {Conversion, RexConvert} from \"../rexes/scalar/convert\";\r\n\r\ndeclare module '../rexes/scalar' {\r\n\tinterface RexScalar<T> {\r\n\t\tconvert<TTo>(conversion : Conversion<T, TTo>) : RexScalar<TTo>;\r\n\t\tconvert<TTo>(to ?: (from : T) => TTo, from ?: (to : TTo) => T)  : RexScalar<TTo>;\r\n\t\trectify<TTo>(to ?: (from : T) => TTo, rectify ?: (to : TTo, from : T) => void) : RexScalar<TTo>;\r\n\r\n\t\tmember<TTo>(name : string)  : RexScalar<TTo>;\r\n\t\tmutate(mutation : (copy : T) => void) : void;\r\n\t\treduce(reducer : (current : T) => T) : void;\r\n\t}\r\n}\r\n\r\nabstract class RexScalarExtensions<T> extends RexScalar<T> {\r\n\tconvert<TTo>(arg1 ?: any, arg2 ?: any) : RexScalar<TTo> {\r\n\t\tif (_.isFunction(arg1) || _.isFunction(arg2)) {\r\n\t\t\treturn new RexConvert<T, TTo>(this, {from: arg1, to: arg2});\r\n\t\t} else if (!arg1 && !arg2) {\r\n\t\t\tthrow new TypeError(\"failed to match any overload for 'convert'.\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn new RexConvert<T, TTo>(this, arg1 as Conversion<T, TTo>);\r\n\t\t}\r\n\t}\r\n\r\n\trectify<TTo>(to ?: (from : T) => TTo, rectify ?: (to : TTo, from : T) => void) {\r\n\t\treturn this.convert(to, to => {\r\n\t\t\tlet clone = _.cloneDeep(this.value);\r\n\t\t\trectify(to, clone);\r\n\t\t\treturn clone;\r\n\t\t});\r\n\t}\r\n\r\n\tmutate(mutation : (copy : T) => void) {\r\n\t\tlet copy = _.cloneDeep(this.value);\r\n\t\tmutation(copy);\r\n\t\tthis.value = copy;\r\n\t}\r\n\r\n\tmember<TTo>(memberName : string) {\r\n\t\treturn this.rectify(from => from[memberName], (to, from) => {\r\n\t\t\tfrom[memberName] = to;\r\n\t\t});\r\n\t}\r\n\r\n\treduce(reducer : (current : T) => T) {\r\n\t\tthis.value = reducer(this.value);\r\n\t}\r\n}\r\n\r\nObject.assign(RexScalar.prototype, RexScalarExtensions.prototype);"],"sourceRoot":"/src"}